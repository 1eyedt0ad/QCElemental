"""
Contains covalent radii
"""

import collections
from decimal import Decimal

from . import datum
from .periodic_table import periodictable

from .exceptions import NotAnElementError


class CovalentRadii:
    """Covalent radii sets.

    Parameters
    ----------
    context : {'ALVAREZ2008'}
        Origin of loaded data.

    Attributes
    ----------
    name : str
        The name of the context ('ALVAREZ2008')
    cr : dict of Datum
        Each covalent radius is an entry in `cr`, where key is the
        "Fe"-cased element symbol if generic or symbol-prefixed label
        if specialized within element. The value is a Datum object with
        `lbl` the same as key, `units`, `data` value as Decimal object,
        and any uncertainty in the `comment` field.
    year : int
        The year the context was created.

    """

    def __init__(self, context="ALVAREZ2008"):
        self.cr = collections.OrderedDict()

        from .data import alvarez_2008_covalent_radii

        if context == "ALVAREZ2008":
            self.doi = alvarez_2008_covalent_radii["doi"]
            #self.raw_covrad = alvarez_2008_covalent_radii["covalent_radii"]
            self.native_units = alvarez_2008_covalent_radii["units"]

            for cr in alvarez_2008_covalent_radii["covalent_radii"]:
                self.cr[cr[0]] = datum.Datum(cr[0], self.native_units, Decimal(cr[1]), cr[2], doi=self.doi)
        else:
            raise KeyError("Context set as '{}', only contexts {'ALVAREZ2008', } are currently supported")

        self.name = context
        self.year = int(alvarez_2008_covalent_radii["date"][:4])

        # Extra relationships
        aliases = [
            ('C',  'angstrom', self.cr['C_sp3'].data,       'Largest (sp3) chosen for generic atom'),
            ('Mn', 'angstrom', self.cr['Mn_highspin'].data, 'Larger (high-spin) chosen for generic atom'),
            ('Fe', 'angstrom', self.cr['Fe_highspin'].data, 'Larger (high-spin) chosen for generic atom'),
            ('Co', 'angstrom', self.cr['Co_highspin'].data, 'Larger (high-spin) chosen for generic atom'),
        ]  # yapf: disable

        # add alternate names to help QC programs
        for alias in aliases:
            ident, units, value, comment = alias
            self.cr[ident.capitalize()] = datum.Datum(ident, units, value, comment)

#        # add constants as directly callable member data
#        for qca in self.pc.values():
#            callname = qca.label.translate(self._transtable)
#            setattr(self, callname, float(qca.data))
#
#    def __str__(self):
#        return "PhysicalConstantsContext(context='{}')".format(self.name)

    def get(self, atom, return_tuple=False, units=None):
        """Access a covalent radius, `atom`.

        Parameters
        ----------
        atom : int or str
            Identifier for element or nuclide, e.g., `H`, `D`, `H2`, `He`, `hE4`.
            In general, one value recommended for each element; however, certain other exact labels may be available.
            ALVAREZ2008: C_sp3, C_sp2, C_sp, Mn_lowspin, Mn_highspin, Fe_lowspin, Fe_highspin, Co_lowspin, Co_highspin
        units : str, optional
            units irrel to tuple

        return_tuple : bool, optional
            See below.

        Returns
        -------
        float
            When ``return_tuple=False``, value of covalent radius. If multiple defined for element, returns largest. If element undefined, ???.
        qcelemental.Datum
            When ``return_tuple=True``, Datum namedtuple with units, description, uncertainty, and value of covalent radius as Decimal (preserving significant figures).
            If multiple defined for element, returns largest. If element undefined, ???.

        Raises
        ------
        NotAnElementError
            If `atom` cannot be resolved into an element or nuclide or label.

        """
        if atom in self.cr.keys():
            # catch extra labels like 'C_sp3'
            identifier = atom
        else:
            identifier = periodictable.to_E(atom)

        qca = self.cr[identifier]

        if return_tuple:
            return qca
        else:
            return qca.to_units(units)

    def string_representation(self):
        """Print name, value, and units of all covalent radii."""

        return datum.print_variables(self.cr)

    def write_c_header(self, filename='covrad.h'):
        """Write C header file defining covalent radii array."""

        text = [
            '#ifndef _qcelemental_covrad_h_',
            '#define _qcelemental_covrad_h_',
            '',
            '/* This file is autogenerated from the QCElemental python module */',
            '',
            'const double covalent_radii[] = {',
        ]

        for el in periodictable.E[1:50]:
            qca = self.cr[el]
            text.append('{},  /*- [{}] {} {} -*/'.format(qca.data, qca.units, qca.label, qca.comment))

        text.append('};')
        text.append('#endif /* header guard */')
        text.append('')

        with open(filename, 'w') as handle:
            handle.write('\n'.join(text))
        print('File written ({}). Remember to add license and clang-format it.'.format(filename))


# singleton
covalentradii = CovalentRadii("ALVAREZ2008")
